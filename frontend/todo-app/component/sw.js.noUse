// public/sw.js - Service worker with reminder functionality and better error handling

self.addEventListener('install', (event) => {
  console.log('Service worker installing...');
  // Wait for the service worker to finish installing
  event.waitUntil(self.skipWaiting());
});

self.addEventListener('activate', (event) => {
  console.log('Service worker activated!');
  // Wait for the service worker to claim all clients
  event.waitUntil(self.clients.claim());
});

// Storage for active reminders
let activeReminders = new Map();

self.addEventListener('message', (event) => {
  try {
    console.log('Received message:', event.data);
    
    // Check if event.data exists and has the expected structure
    if (!event.data || typeof event.data !== 'object') {
      console.error('Invalid message data:', event.data);
      return;
    }
    
    const { type, data } = event.data;
    
    if (type === 'SCHEDULE_REMINDER') {
      if (data) {
        scheduleReminder(data);
      } else {
        console.error('SCHEDULE_REMINDER: No data provided');
      }
    }
    
    if (type === 'CANCEL_REMINDER') {
      if (data && data.id) {
        cancelReminder(data.id);
      } else {
        console.error('CANCEL_REMINDER: No ID provided');
      }
    }
    
    if (type === 'SHOW_NOTIFICATION_NOW') {
      if (data && data.title && data.message) {
        showNotification(data.title, data.message);
      } else {
        console.error('SHOW_NOTIFICATION_NOW: Missing title or message');
      }
    }
  } catch (error) {
    console.error('Error handling message:', error);
  }
});

// Function to schedule a reminder
function scheduleReminder(reminderData) {
  try {
    const { id, title, message, dateTime } = reminderData;
    
    // Validate required fields
    if (!id || !title || !message || !dateTime) {
      console.error('Missing required fields for reminder:', reminderData);
      return;
    }
    
    // Calculate delay until reminder time
    const targetTime = new Date(dateTime).getTime();
    const currentTime = new Date().getTime();
    const delay = targetTime - currentTime;
    
    console.log(`Scheduling reminder "${title}" for ${new Date(dateTime)}`);
    console.log(`Delay: ${delay}ms (${Math.round(delay/1000/60)} minutes)`);
    
    if (isNaN(targetTime)) {
      console.error('Invalid dateTime format:', dateTime);
      return;
    }
    
    if (delay <= 0) {
      // If time has already passed, show immediately
      showNotification(title, `${message} (Overdue!)`);
      return;
    }
    
    // Cancel existing reminder with same ID
    cancelReminder(id);
    
    // Schedule the reminder
    const timeoutId = setTimeout(() => {
      try {
        showNotification(title, message);
        // Remove from active reminders
        activeReminders.delete(id);
        console.log(`Reminder "${title}" triggered and removed`);
      } catch (error) {
        console.error('Error showing notification:', error);
      }
    }, delay);
    
    // Store the timeout ID so we can cancel it later
    activeReminders.set(id, {
      timeoutId,
      title,
      message,
      dateTime
    });
    
    console.log(`Active reminders: ${activeReminders.size}`);
  } catch (error) {
    console.error('Error scheduling reminder:', error);
  }
}

// Function to cancel a reminder
function cancelReminder(id) {
  try {
    if (activeReminders.has(id)) {
      const reminder = activeReminders.get(id);
      clearTimeout(reminder.timeoutId);
      activeReminders.delete(id);
      console.log(`Cancelled reminder: ${id}`);
    } else {
      console.log(`Reminder not found for cancellation: ${id}`);
    }
  } catch (error) {
    console.error('Error cancelling reminder:', error);
  }
}

// Function to show notification
async function showNotification(title, message) {
  try {
    // Check if notifications are supported and permission is granted
    if (!('showNotification' in self.registration)) {
      console.error('Notifications not supported');
      return;
    }
    
    // Request permission if not already granted
    const permission = await self.registration.showNotification(title, {
      body: message,
      icon: '/favicon.ico',
      badge: '/favicon.ico',
      tag: `reminder-${Date.now()}`,
      requireInteraction: true,
      data: { 
        originalTitle: title, 
        originalMessage: message,
        timestamp: Date.now()
      },
      actions: [
        {
          action: 'dismiss',
          title: 'Dismiss'
        }
      ]
    });
    
    console.log(`Notification shown: "${title}"`);
    return permission;
    
  } catch (error) {
    console.error('Error showing notification:', error);
    // Fallback: log the notification instead
    console.log(`NOTIFICATION: ${title} - ${message}`);
  }
}

// Handle notification clicks
self.addEventListener('notificationclick', (event) => {
  console.log('Notification clicked!', event.action);
  
  // Close the notification
  event.notification.close();
  
  // Handle different actions
  if (event.action === 'dismiss') {
    console.log('Notification dismissed');
    return;
  }
  
  // Focus or open your app
  event.waitUntil(
    self.clients.matchAll({ type: 'window', includeUncontrolled: true })
      .then(clientList => {
        console.log('Found clients:', clientList.length);
        
        // If app is already open, focus it
        for (let i = 0; i < clientList.length; i++) {
          const client = clientList[i];
          if (client.url.includes(self.location.origin) && 'focus' in client) {
            console.log('Focusing existing client');
            return client.focus();
          }
        }
        
        // If app is not open, open it
        if (self.clients.openWindow) {
          console.log('Opening new window');
          return self.clients.openWindow('/');
        }
        
        console.log('Cannot open window');
      })
      .catch(error => {
        console.error('Error handling notification click:', error);
      })
  );
});

// Handle notification close
self.addEventListener('notificationclose', (event) => {
  console.log('Notification closed:', event.notification.tag);
});

// Debug: Log all active reminders every minute
setInterval(() => {
  try {
    console.log(`Active reminders: ${activeReminders.size}`);
    if (activeReminders.size > 0) {
      for (let [id, reminder] of activeReminders) {
        const timeLeft = new Date(reminder.dateTime).getTime() - Date.now();
        console.log(`- ${id}: ${reminder.title} at ${reminder.dateTime} (${Math.round(timeLeft/1000/60)} min left)`);
      }
    }
  } catch (error) {
    console.error('Error in debug interval:', error);
  }
}, 60000);

// Global error handler
self.addEventListener('error', (event) => {
  console.error('Service worker error:', event.error);
});

// Handle unhandled promise rejections
self.addEventListener('unhandledrejection', (event) => {
  console.error('Unhandled promise rejection in service worker:', event.reason);
  event.preventDefault(); // Prevent the error from being logged to console again
});